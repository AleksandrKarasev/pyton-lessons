# Лекция № 3. Функции, рекурсия, алгоритмы

## Функция

**Функция** - *это фргамент кода используемый многократно*

```py
def function(arguments):
    # body1
    #bode n
    # optional return
```

### Пример

Нужно создать функцию которая просуммирует числа от 1 до n 

### Код 
```py
def sumNumbers(n):
    summa=0
    for i in range(1,n+1):
        summa+=i
    
    print(summa)

sumNumbers(5)
```

### Через возвращемые значения 
```py
def sumNumbers(n):
    summa=0
    for i in range(1,n+1):
        summa+=i
    return summa

a=sumNumbers(5)
print(a)
```

### Функция с передачей неограниченное кол-во элементов
```py
def sum_str(*args):
    res=''
    for i in args:
        res+=str(i)
    return res

print(sum_str('q','w','e','r','t','y'))
print(sum_str(1,2,3,4,5))
```

## Модульность 
**это создание в отдельном файле функции и вызов их в основном файле**

### Пример 
Создаем файл modul.py и пишем там функцию 

```py
def max1(a,b):
    if (a>b):
        return a
    return b
```

### Основной файл 
```py
import modul

print(modul.max1(5,9))
```

#### Импорт 
```import modul1``` - *импортирует файл и в нем функции*

`from modul import max1` - *импортируем именно функцию*

`from modul import *` - *импортируем все функции из файла*

`import modul1 as m1` - *импортируем файл в котором функции и делаем alias*

## Рекурсия 

**Рекурсия** - *это функция которая вызывает сама себя*

При описании рекурсии важно указать когда функции надо остановить и перестать вызвать саму себя 

По другому указать базис рекурсии 

### Пример 
Пользователь вводит число n. 

Необходимо вывести n  первых членов последовательности Фибоначи

### Код
```py
def fib(n):
    if n in [1,2]:
        return 1
    else :
        return fib(n-1) + fib(n-2)
    
list_1=list()
for i in range (1,10):
    list_1.append(fib(i))

print(list_1)
```

## Алгоритмы 

**Алгоритмом** *называется набор инструкций для выполнения некоторой функции 

* __Быстрая сортировка__
* __Сортировка слиянием__

### Быстрая сортировка 

#### Код
```py
def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
    less = [i for i in array[1:] if i <= pivot]
    greater = [i for i in array[1:] if i > pivot]
    return quicksort(less) + [pivot] + quicksort(greater)
print(quicksort([10, 5, 2, 3]))
```

#### Разборка рекурсии 
1-е повторение : 
```py
    array=[10,5,2]
    pivot=10
    less=[5,2]
    greater=[]
    return quicksort([5,2]) + [pivot] + quicksort([])
```
2-e повторение : 
```py
    array=[5,2]
    pivot=5
    less=[2]
    greatest=[]
    return quicksort([2]) + [5] + quicksort([])
# + добавление число 10
```
3-е повторение : 
```py
    array=[2]
    retun[2]
```
Вывод [2]+[5]+[10] = [2,5,10]

#### Сортировка слиянием 
```py
def mergesort(nums):
    if len(nums)>1:
        mid=len(nums)//2
        left=nums[mid:]
        right=nums[:mid]
        mergesort(left)
        mergesort(right)
        i=j=k=0
        while i<len(left) and j<len(right):
            if left[i]<right[j]:
                nums[k]=left[i]
                i+=1
            else :
                nums[k]=right[j]
                j+=1
            k+=1

        while i<len(left):
            nums[k]=left[i]
            i+=1
            k+=1
        while j<len(right):
            nums[k]=right[j]
            j+=1
            k+=1
        
list_1=[1,5,6,9,8,7,2,1,55,2,4]
mergesort(list_1)
print(list_1)
```